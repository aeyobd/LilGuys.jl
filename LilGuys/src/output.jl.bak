using HDF5
using LinearAlgebra: norm
using Printf




Base.@kwdef struct Output <: AbstractArray{Particle, 2}
    pos::Array{F, 3}
    vel::Array{F, 3}
    acc::Array{F, 3}
    Φ::Matrix{F}
    Φ_ext::Matrix{F}
    index::Matrix{Int}
    time::Vector{F}
    header::Dict{String, Any}
    m::F
    h::F = NaN
end


function Output(filename::String; mmap=true)
    kwargs = Dict{Symbol, Any}()

    h5open(filename, "r") do h5f
        for (var, header) in h5vectors
            kwargs[var] = get_vector(h5f, header, mmap=mmap)
        end

        header = get_header(h5f)
        kwargs[:header] = header
        kwargs[:time] = read(h5f["Time"])
        kwargs[:m] = header["MassTable"][1]
    end
    return Output(; kwargs...)
end



# snapshot methods

Base.size(out::Output) = size(out.Φ)
Base.IndexStyle(::Type{<:Output}) = IndexCartesian()



function Base.getindex(snap::Output, i::Int, j::Int)
    kwargs = Dict{Symbol, Any}()
    kwargs[:m] = snap.m
    kwargs[:h] = snap.h

    for sym in [:Φ, :Φ_ext, :index]
        kwargs[sym] = getproperty(snap, sym)[i, j]
    end
    for sym in [:pos, :vel, :acc]
        kwargs[sym] = getproperty(snap, sym)[i, :, j]
    end
    return Particle(; kwargs...)
end



function Base.show(io::IO, out::Output)
    print(io, "<output of size $(size(out)) >")
    return io
end



